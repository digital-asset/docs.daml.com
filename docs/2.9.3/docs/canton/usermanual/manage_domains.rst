..
   Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates.
..
   Proprietary code. All rights reserved.

Manage Synchronization Domains
==============================

.. _permissioned-domains:

Permissioned Synchronization Domains
------------------------------------

.. enterprise-only::

Canton as a network is an open virtual shared ledger. Whoever runs a Canton participant node is part of the same
virtual shared ledger. However, the network itself is made up of sync domains that are used by participants to run the Canton
protocol and communicate to their peers. Such sync domains can be `open`, allowing any participant with access to
a sequencer node to enter and participate in the network. But sync domains can also be **permissioned**, where the operator
of the sync domain topology managers needs to explicitly add the participant to the allow-list before the participant
can register with a sync domain.

While the Canton architecture is designed to be resilient against malicious participants, there can never be a
guarantee that the implementation of said architecture is absolutely secure. Therefore, it makes sense for most
networks to impose control on which participant can be part of the network.

The first layer of control is given by securing access to the public API of the sequencers in the network. This
can be done using standard network tools such as firewalls and virtual private networks.

The second layer of control is given by setting the appropriate configuration flag of the sync domain manager (or sync domain):

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/resources/documentation-snippets/permissioned-domain-manager1.conf

Assuming we have set up a sync domain with this flag turned off, the config for that particular sync domain would read:

.. snippet:: permissioned_domain
    .. assert:: { domainManager1.setup.bootstrap_domain(Seq(sequencer1), Seq(mediator1)); true }
    .. success(output=5):: val config = DomainConnectionConfig("mydomain", sequencer1.sequencerConnection)

When a participant attempts to join the sync domain, it will be rejected:

.. snippet:: permissioned_domain
    .. failure:: participant1.domains.register(config)
    .. assert:: participant1.domains.list_connected().isEmpty

In order to allow the participant to join the sync domain, we must first actively enable it on the topology
manager. We assume now that the operator of the participant :ref:`extracts its id <getting-started-extracting-ids>`
into a string:

.. snippet:: permissioned_domain
    .. success:: val participantAsString = participant1.id.toProtoPrimitive

and communicates this string to the operator of the sync domain topology manager:

.. snippet:: permissioned_domain
    .. success:: val participantIdFromString = ParticipantId.tryFromProtoPrimitive(participantAsString)

This topology manager can now add the participant by enabling it:

.. snippet:: permissioned_domain
    .. success:: domainManager1.participants.set_state(participantIdFromString, ParticipantPermission.Submission, TrustLevel.Ordinary)

Note that the participant is not active yet:

.. snippet:: permissioned_domain
    .. success:: domainManager1.participants.active(participantIdFromString)
    .. assert:: !domainManager1.participants.active(participantIdFromString)

So far, what we've done with setting the state is to issue a "sync domain trust certificate", where the sync domain
topology manager declares that it trusts the participant enough to become a participant of the sync domain.
We can inspect this certificate using:

.. snippet:: permissioned_domain
    .. success:: domainManager1.topology.participant_domain_states.list(filterStore="Authorized").map(_.item)
    .. assert:: domainManager1.topology.participant_domain_states.list(filterStore="Authorized").map(_.item.side) == Seq(RequestSide.From)

In order to have the participant become active on the sync domain, we need to register the signing keys and
the "sync domain trust certificate" of the participant. The certificate is generated by the participant
automatically and sent to the sync domain during the initial handshake.

We can trigger that handshake again by attempting to reconnect to the sync domain:

.. snippet:: permissioned_domain
    .. success:: participant1.domains.reconnect_all()
    .. assert:: participant1.domains.list_connected().nonEmpty

Now, we can check that the participant is active:

.. snippet:: permissioned_domain
    .. success:: domainManager1.participants.active(participantIdFromString)
    .. assert:: domainManager1.participants.active(participantIdFromString)

We can also observe that we now have both sides of the sync domain trust certificate, the ``From`` and the ``To``:

.. snippet:: permissioned_domain
    .. success:: domainManager1.topology.participant_domain_states.list(filterStore="Authorized").map(_.item)
    .. assert:: domainManager1.topology.participant_domain_states.list(filterStore="Authorized").map(_.item.side).toSet == Set(RequestSide.From, RequestSide.To)

Finally, the participant is healthy and can use the sync domain:

.. snippet:: permissioned_domain
    .. success:: participant1.health.ping(participant1)


Synchronization Domain Rules
----------------------------
Every sync domain has its own rules in terms of what parameters are used by the participants while
running the protocol. The participants obtain these parameters before connecting to the sync domain.
They can be configured using the specific parameter section. An example would be:

.. literalinclude:: /canton/includes/mirrored/enterprise/integration-testing/src/main/resources/include/domain-parameters.conf

The full set of available parameters can be found in the `scala reference documentation <https://docs.daml.com/__VERSION__/canton/scaladoc/com/digitalasset/canton/domain/config/DomainParametersConfig.html>`_.

Dynamic synchronization domain parameters
-----------------------------------------

.. _dynamic_domain_parameters:

In addition to the parameters that are specified in the configuration, some parameters can be changed at runtime (i.e.,
while the sync domain is running); these are called **dynamic sync domain parameters**. When the sync domain is bootstrapped, default
values are used for the dynamic sync domain parameters. They can be changed subsequently using the console commands described
below.

A participant can get the current parameters on a sync domain it is connected to using the following command:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/dynamicdomainparameters/DomainParametersChangeIntegrationTest.scala
   :language: scala
   :start-after: user-manual-entry-begin:-begin: GetDynamicDomainParameters
   :end-before: user-manual-entry-begin:-end: GetDynamicDomainParameters
   :dedent:

Parameters that were transitioned from static to dynamic with protocol version 4 need to be retrieved individually:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/dynamicdomainparameters/DomainParametersChangeIntegrationTest.scala
   :language: scala
   :start-after: user-manual-entry-begin:-begin: GetSingleDynamicDomainParameter
   :end-before: user-manual-entry-begin:-end: GetSingleDynamicDomainParameter
   :dedent:

Dynamic parameters can be set individually using:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/dynamicdomainparameters/DomainParametersChangeIntegrationTest.scala
   :language: scala
   :start-after: user-manual-entry-begin:-begin: SetDynamicDomainParameters
   :end-before: user-manual-entry-begin:-end: SetDynamicDomainParameters
   :dedent:

Alternatively, several can be set at the same time:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/dynamicdomainparameters/DomainParametersChangeIntegrationTest.scala
   :language: scala
   :start-after: user-manual-entry-begin:-begin: UpdateDynamicDomainParameters
   :end-before: user-manual-entry-begin:-end: UpdateDynamicDomainParameters
   :dedent:

.. note::

    When increasing `max request size`, the sequencer nodes need to be restarted
    for the new value to be taken into account. If the sync domain is not distributed,
    it means that the sync domain node needs to be restarted.

Recover From a Small Max Request Size
-------------------------------------
`MaxRequestSize` is a dynamic parameter starting from protocol version 4. This parameter configures both
the gRPC channel size on the sequencer node and the maximum size that a sequencer client is allowed to transfer.

If the parameter is set to a very small value (roughly under `30kb`), Canton can crash because all messages are rejected by the sequencer client or
by the sequencer node. This cannot be corrected by setting a higher value within the console, because this change request needs to be sent via the sequencer and will
also be rejected.

To recover from this crash, you need to configure `override-max-request-size` on both the sequencer node and the sequencer clients.

On a non-distributed deployment, this means modifying both the sync domain and the participant configuration as follows:

.. code-block:: none

    domains {
      da {
        # overrides the maxRequestSize in bytes on the sequencer node
        public-api.override-max-request-size = 30000
        sequencer-client.override-max-request-size = 30000
      }
    }
    participants {
      participant1 {
        sequencer-client.override-max-request-size = 30000
      }
      participant2 {
        sequencer-client.override-max-request-size = 30000
      }
    }

On a distributed deployment, for each sync domain entity deployed on its own node,
you will need to override the `max-request-size` as follows:

.. code-block:: none

    domain-managers {
      domainManager1 {
        sequencer-client.override-max-request-size = 30000
      }
    }
    participants {
      participant1 {
        sequencer-client.override-max-request-size = 30000
      }
      participant2 {
        sequencer-client.override-max-request-size = 30000
      }
    }
    mediators {
      mediator1 {
        sequencer-client.override-max-request-size = 30000
      }
    }
    sequencers {
      sequencer1 {
        # overrides the maxRequestSize in bytes on the sequencer node
        public-api.override-max-request-size = 30000
        sequencer-client.override-max-request-size = 30000
      }
    }


After the configuration is modified, disconnect all the participants from the sync domain and then restart all nodes.

On a non-distributed deployment, you can stop Canton by following these steps:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/MaxRequestSizeCrashTest.scala
   :language: scala
   :start-after: user-manual-entry-begin: StopNonDistributedCanton
   :end-before: user-manual-entry-end: StopNonDistributedCanton
   :dedent:

On a distributed deployment, you can stop Canton by following these steps:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/MaxRequestSizeCrashTest.scala
   :language: scala
   :start-after: user-manual-entry-begin: StopDistributedCanton
   :end-before: user-manual-entry-end: StopDistributedCanton
   :dedent:

Then perform the restart:

.. literalinclude:: /canton/includes/mirrored/enterprise/app/src/test/scala/com/digitalasset/canton/integration/tests/MaxRequestSizeCrashTest.scala
   :language: scala
   :start-after: user-manual-entry-begin: RestartCanton
   :end-before: user-manual-entry-end: RestartCanton
   :dedent:

Once Canton has recovered, use the admin command to set the `maxRequestSize` value, then delete the added configuration
in the previous step, and finally perform the restart again.
